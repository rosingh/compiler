from collections import deque

i = 0
arg_num = 0
static_size = 1 #reserve space for NULL
label_id = 0
live_registers = []
current_label = None
#Stacks of labels
break_labels = []
continue_labels = []
processed_method_labels = []
#key = method label(callee); value = list of blocks containing ret
blocks_containing_return = {}
#key = method label (callee); value = list of ret. addresses waiting to be linked to callee
return_to_labels = {}
#control flow graph - maps label names to dict containing pred. and succ.
cfg = {}
import pprint

def get_live_registers():
  registers = []
  for level in live_registers:
    registers += level
  return registers

def kill_registers_scope():
  global live_registers
  live_registers.pop()

def start_registers_scope():
  global live_registers
  live_registers.append([])

def add_register_to_scope(reg):
  global live_registers
  live_registers[-1].append(reg)

def get_break_label():
  if len(break_labels) > 0:
    return break_labels[-1]
  else:
    return None

def get_continue_label():
  if len(continue_labels) > 0:
    return continue_labels[-1]
  else:
    return None

def generate_temporary_register(noscope=False):
  global i
  reg = 't' + str(i)
  i += 1
  if not noscope:
    add_register_to_scope(reg)
  return reg

def generate_argument_register():
  global arg_num
  reg = 'a' + str(arg_num)
  arg_num += 1
  return reg

def reset_argument_register(storage):
  global arg_num
  if storage == 'instance':
    arg_num = 1
  else:
    arg_num = 0

def allocate_static_space():
  global static_size
  static_size += 1
  return static_size - 1

def get_new_label():
  global label_id, cfg
  label_id += 1
  label_name =  'L' + str(label_id - 1)
  cfg[label_name] = {'predecessors' : [], 'successors' : []}
  return label_name

#label : new current label
#link : True if we want a connection btwn prev label and this one in cfg
#       False if there is no connection btwn the prev label and this one (i.e, jmp)
def set_current_label(label, link):
  global current_label
  prev_label = current_label
  current_label = label

  #for labels not autogenerated by get_new_label
  if current_label not in cfg:
    cfg[current_label] = {'predecessors' : [], 'successors' : []}
  #sets up the entries for returns/calls
  if current_label[0] != 'L':
    blocks_containing_return[current_label] = []
    return_to_labels[current_label] = []
  #connects the functions to its first label
  if link or (current_label[0] == 'L' and prev_label is not None and prev_label[0] != 'L'):
    add_links_to_cfg(label, [prev_label])

  return [(label + ':',)]

def get_current_label():
  return current_label

def jump(jmp_label):
  add_links_to_cfg(jmp_label)
  return [('jmp', jmp_label)]

#register = register being compared [to 0]
#b_label = branch label
#on_zero = True if branch on zero
#          False if branch on not zero
def branch(register, b_label, on_zero):
  inst = 'bnz'
  if on_zero:
    inst = 'bz'

  add_links_to_cfg(b_label)
  return [(inst, register, b_label)]

#m_or_c = 'M' if method call
#         'C' if new obj
#f_name = function name ('' if constructor)
#f_id = function id
def call(function_label):
  add_links_to_cfg(function_label)
  #call the label
  code = [('call', function_label)]

  #create a new block (b/c call is technically a jump)
  next_label = get_new_label()
  code += set_current_label(next_label, False)

  #connect created block w/ ret blocks from the func. call if func was fully processed
  if function_label in processed_method_labels:
    add_links_to_cfg(current_label, blocks_containing_return[function_label])
  #the callee isn't fully processed
  else:
      #queue it up in its return_to_labels entry
      return_to_labels[function_label].append(current_label)

  return code

def ret(function_label):
  blocks_containing_return[function_label].append(current_label)
  return [('ret',)] + set_current_label(get_new_label(), False)

def finished_processing(function_label):
  processed_method_labels.append(function_label)
  #LINK SHIT UP! :DDDDD
  for ret_addr in return_to_labels[function_label]:
    #ret. addrs, 
    add_links_to_cfg(ret_addr, blocks_containing_return[function_label])

def add_links_to_cfg(jmp_label, from_labels=None):
  global cfg
  
  #if from_labels isn't used, just use current_label as default
  if from_labels is None:
    from_labels = [current_label]

  for curr_label in from_labels:
    cfg[curr_label]['successors'].append(jmp_label)
    cfg[jmp_label]['predecessors'].append(curr_label)

def is_prev_arg(arg1, arg2):
  if arg1[0] != 'a' or arg2[0] != 'a':
    return False
  if arg1[1:] < arg2[1:]:
    return True
  return False

def generate_ssa(code):
  defined_regs_in_block = {}
  curr_pass_block = None
  for inst in code:
    #beginning of a new basic block
    if len(inst) == 1 and inst[0][-1] == ':':
      defined_regs_in_block[inst[0]] = {}
      curr_pass_block = inst[0]
    #check if instruction assigns stuff to a register
    elif len(inst) > 2 and inst[0] != 'hstore' and inst[0][0] != 'b' and \
     (inst[0] != 'move' or inst[1][0] != 'a'):
      print inst
      #this is the first time this register is being used in this block
      if inst[1] not in defined_regs_in_block[curr_pass_block]:
        defined_regs_in_block[curr_pass_block][inst[1]] = 1
      #this register being used multiple times in the same block
      else:
        defined_regs_in_block[curr_pass_block][inst[1]] += 1
  #print 'Defined registers:'
  #pprint.pprint(defined_regs_in_block)
  used_regs_in_block = {}
  curr_pass_block = None
  for inst in code:
    #beginning of a new basic block
    if len(inst) == 1 and inst[0][-1] == ':':
      used_regs_in_block[inst[0]] = {}
      curr_pass_block = inst[0]
    #check if inst uses reg
    elif len(inst) == 3:
      if inst[0] != 'bz' and inst[0] != 'bnz' and inst[0] != 'move_immed_i' and inst[0] != 'move_immed_f':
        if inst[2] not in used_regs_in_block[curr_pass_block]:
          used_regs_in_block[curr_pass_block][inst[2]] = 1
        else:
          used_regs_in_block[curr_pass_block][inst[2]] += 1
      elif inst[0] == 'bz' or inst[0] == 'bnz':
        if inst[1] not in used_regs_in_block[curr_pass_block]:
          used_regs_in_block[curr_pass_block][inst[1]] = 1
        else:
          used_regs_in_block[curr_pass_block][inst[1]] += 1
    elif len(inst) == 4:
      if inst[0] == 'hstore':
        if inst[1] not in used_regs_in_block[curr_pass_block]:
          used_regs_in_block[curr_pass_block][inst[1]] = 1
        else:
          used_regs_in_block[curr_pass_block][inst[1]] += 1
      if inst[2] not in used_regs_in_block[curr_pass_block]:
          used_regs_in_block[curr_pass_block][inst[2]] = 1
      else:
        used_regs_in_block[curr_pass_block][inst[2]] += 1
      if inst[3] not in used_regs_in_block[curr_pass_block]:
          used_regs_in_block[curr_pass_block][inst[3]] = 1
      else:
        used_regs_in_block[curr_pass_block][inst[3]] += 1
  #print 'Used registers:'
  #pprint.pprint(used_regs_in_block)

  register_info = {}
  inst_to_skip = ('jmp', 'call', 'ret')
  inst_no_define = ('bz', 'bnz', 'hstore', 'save', 'restore')
  inst_immed = ('move_immed_i', 'move_immed_f', 'bz' 'bnz', 'jmp')
  curr_label = None
  for index, inst in enumerate(code):
    #this is a label! => begins another blocccc :D
    if inst[0][-1] == ':':
      curr_label = inst[0]
    #ignore instructions we're supposed to skip and comments
    elif inst[0] not in inst_to_skip and inst[0][0] != '#':
      #if len(inst) > 2 and inst[0] != 'hstore' and \
      #  (inst[0] != 'move' or inst[1][0] != 'a'):
      if len(inst) > 2:
        for i in range(1, len(inst)):
          #if its not a register, we just ignore it
          if not is_register(inst[i]):
            continue
          #this is the first time this register is being accessed
          if inst[i] not in register_info:
            register_info[inst[i]] = {}
            register_info[inst[i]]['def'] = []
            register_info[inst[i]]['use'] = []
          #not the first op
          if i >= 2:
            #register instruction => all ops are registers :D
            if inst[0] not in inst_immed:
              register_info[inst[i]]['use'].append([curr_label[:-1], index])
          #first op
          else:
            if inst[0] not in inst_no_define:
              register_info[inst[i]]['def'].append([curr_label[:-1], index])
              #if its been defined before
              if len(register_info[inst[i]]['def']) > 1:
                register_info[inst[i]]['def'][-1].append(generate_temporary_register(True))
              else:
                register_info[inst[i]]['def'][-1].append(inst[i])
            else:
              register_info[inst[i]]['use'].append([curr_label[:-1], index])
        #print inst
        
  pprint.pprint(register_info)
  #go through all of teh register entries
  for reg_entry in register_info.values():
    #if they are defined at most once, we dont have to fix use registers
    if len(reg_entry['def']) <= 1:
      continue
    #look at each use case
    print '=============='
    print 'CURRENT_REG_ENTRY:', reg_entry
    for usage in reg_entry['use']:
      print '--------------'
      print 'USAGE:', usage
      reg = None
      possible_regs = []
      reg_defs = reg_entry['def']
      print 'REG_DEFS', reg_defs
      use_loc = usage
      reg = propogate_register(use_loc, reg_defs)
      if reg is None:
        #need to traverse the graph
        use_locs = cfg[use_loc[0]]['predecessors']
        visited_locs = []
        #need to find the predecessors
        #while we havent visited all of the locs
        nodes_to_visit = deque()
        '''while not set(visited_locs).issuperset(set(use_locs)) > 0:
          for use_loc in use_locs:
            if use_loc in visited_locs:
              continue
            print 'USE_LOC:', use_loc
            reg = propogate_register([use_loc], reg_defs)
            if reg is not None:
              possible_regs.append(reg)
            visited_locs.append(use_loc)
          if len(possible_regs) == 0:
            new_use_locs = []
            for use_loc in use_locs:
              new_use_locs += cfg[use_loc]['predecessors']
              print new_use_locs
            use_locs = new_use_locs
          print 'VISITED LOCS:',visited_locs
        print 'POSSIBLE REGS:', possible_regs
      if len(possible_regs) == 1:
        reg = possible_regs[0]
      elif len(possible_regs) > 1:
        reg = possible_regs'''

      print 'USE_LOC:', use_loc
      reg = get_usage_register([use_loc], reg_defs, [])
      usage.append(reg)
      print 'REG:', reg
      print 'updated usage:', usage

def get_usage_register(locs, reg_defs, visited):
  if len(locs) < 1:
    return None
  registers = []
  def_def_registers = []
  #get the register for this location
  for loc in locs:
    registers.append(propogate_register(loc, reg_defs))
  print "registers : ", registers
  #loop through all of these registers/locs
  for idx, reg in enumerate(registers):
    print "LOCS", locs
    print "IDX", idx
    next_loc = cfg[locs[idx][0]]['predecessors']
    print "VISITED", visited
    print "LOC", next_loc
    #if we couldnt figure out the register and havent visited its pred.
    if reg is None and next_loc not in visited:
      print "PRED", next_loc
      new_locs = map(lambda l:[l], next_loc)
      #see if we can propogate the register from pred.
      r = get_usage_register(new_locs, reg_defs, visited)
      print "(", locs[idx][0], ")", new_locs, "=>", r
      #if we managed to propogate something
      if r is not None:
        #registers[idx] = r 
        print "DEFINITELY DEFINED", r, "(", len(r), ")"
        #this register is definely, defined
        if len(r) == 1:
          def_def_registers.append(r[0])
        else:
          def_def_registers.append(r)
    #this reg. was def. earlier in the block
    elif reg is not None:
      #its def. defined
      def_def_registers.append(reg)
    else:
      print "VISITED", next_loc, "ALREADY"
    #print loc, '=>', registers[idx]
    print "LOC", next_loc
    print "LOCS", locs
    print "IDX", idx
    #we visited this location
    visited.append(loc)
   # print "VISITED " + loc
  if def_def_registers is not None and len(def_def_registers) == 1:
    def_def_registers = def_def_registers[0]
  return def_def_registers
# use_loc = location of usage
#   if this is a list of size 2, we know line # => this is current block
#   if this is a list of size 1, must be a pred. block (dont need to check line#)
# reg_def = all the locations where this register is defined
#   will be in the form of (block_label, line#, register)
def propogate_register(use_loc, reg_defs):          
  def_in_same_block_list = filter(lambda ent: ent[0] == use_loc[0], reg_defs)
  #there is at least 1 instance where this reg. is defined in the same block as used
  if len(def_in_same_block_list) > 0:
    if len(use_loc) < 2:
      return def_in_same_block_list[-1][2]
    #now we gotta make sure that def is before use
    for possible_reg_assignment in reversed(def_in_same_block_list):
      if possible_reg_assignment[1] < use_loc[1]:
        return possible_reg_assignment[2]
  return None
            

  pprint.pprint(register_info)
  #for inst in code:
  #  if len(inst) == 0:
  #    curr_pass_label = inst[0]
  #  elif 
def is_register(value):
  if value[0] == 't' or value[0] == 'a':
    return True
  return False

